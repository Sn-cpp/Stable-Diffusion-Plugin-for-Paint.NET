using System.Reflection;
using System.Text;
using System.Text.Json;
using System.Runtime.InteropServices;
using System.Runtime.Versioning;
using PaintDotNet;
using PaintDotNet.Effects;
using PaintDotNet.Imaging;
using PaintDotNet.IndirectUI;
using PaintDotNet.PropertySystem;
using PaintDotNet.Rendering;
using ReseedButtonControl = System.Byte;
using IntSliderControl = System.Int32;
using MultiLineTextboxControl = System.String;
using LabelComment = System.String;
using System.Runtime.CompilerServices;
using System.Drawing;
using System.Drawing.Imaging;
using System.Data;
using PropertyCollection = PaintDotNet.PropertySystem.PropertyCollection;
using static PaintDotNet.Effects.SurfaceBlurEffect;

[assembly: AssemblyTitle("DiffusionPlugin plugin for Paint.NET")]
[assembly: AssemblyDescription("Diffusion selected pixels")]
[assembly: AssemblyConfiguration("diffusion")]
[assembly: AssemblyCompany("Sn")]
[assembly: AssemblyProduct("DiffusionPlugin")]
[assembly: AssemblyCopyright("Copyright ©2025 by Sn")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]
[assembly: ComVisible(false)]
[assembly: AssemblyVersion("1.0.0")]
[assembly: AssemblyMetadata("BuiltByCodeLab", "Version=6.13.9087.35650")]
[assembly: SupportedOSPlatform("Windows")]

namespace DiffusionPlugin
{
    public class DiffusionPluginSupportInfo : IPluginSupportInfo
    {
        public string Author => base.GetType().Assembly.GetCustomAttribute<AssemblyCopyrightAttribute>().Copyright;
        public string Copyright => base.GetType().Assembly.GetCustomAttribute<AssemblyDescriptionAttribute>().Description;
        public string DisplayName => base.GetType().Assembly.GetCustomAttribute<AssemblyProductAttribute>().Product;
        public Version Version => base.GetType().Assembly.GetName().Version;
        public Uri WebsiteUri => new Uri("");
    }

    [PluginSupportInfo<DiffusionPluginSupportInfo>(DisplayName = "Diffusion")]
    public class DiffusionPluginEffectPlugin : PropertyBasedBitmapEffect
    {
        //Name displayed in menu
        public static string StaticName => "Diffusion";

        //No icon yet
        public static System.Drawing.Image StaticIcon => null;

        //No sub-menu needed
        public static string SubmenuName => null;

        //Constructor of the effect plugin
        public DiffusionPluginEffectPlugin()
            : base(StaticName, StaticIcon, SubmenuName, BitmapEffectOptions.Create() with { IsConfigurable = true })
        {
            RandomNumberInstanceSeed = unchecked((uint)DateTime.Now.Ticks);
        }

        //Enum for UI elements name
        public enum PropertyNames
        {
            AlertStr,
            PromptStr,
            NgtPromptStr,
            StepCount,
            DeNoiseStrength,
            GenButton
        }

        //Generated by CodeLab-----
        #region Random Number Support
        private readonly uint RandomNumberInstanceSeed;
        private uint RandomNumberRenderSeed = 0;

        internal static class RandomNumber
        {
            public static uint InitializeSeed(uint iSeed, float x, float y)
            {
                return CombineHashCodes(
                    iSeed,
                    CombineHashCodes(
                        Hash(Unsafe.As<float, uint>(ref x)),
                        Hash(Unsafe.As<float, uint>(ref y))));
            }

            public static uint InitializeSeed(uint instSeed, Point2Int32 scenePos)
            {
                return CombineHashCodes(
                    instSeed,
                    CombineHashCodes(
                        Hash(unchecked((uint)scenePos.X)),
                        Hash(unchecked((uint)scenePos.Y))));
            }

            public static uint Hash(uint input)
            {
                uint state = input * 747796405u + 2891336453u;
                uint word = ((state >> (int)((state >> 28) + 4)) ^ state) * 277803737u;
                return (word >> 22) ^ word;
            }

            public static float NextFloat(ref uint seed)
            {
                seed = Hash(seed);
                return (seed >> 8) * 5.96046448E-08f;
            }

            public static int NextInt32(ref uint seed)
            {
                seed = Hash(seed);
                return unchecked((int)seed);
            }

            public static int NextInt32(ref uint seed, int maxValue)
            {
                seed = Hash(seed);
                return unchecked((int)(seed & 0x80000000) % maxValue);
            }

            public static int Next(ref uint seed)
            {
                seed = Hash(seed);
                return unchecked((int)seed);
            }

            public static int Next(ref uint seed, int maxValue)
            {
                seed = Hash(seed);
                return unchecked((int)(seed & 0x80000000) % maxValue);
            }

            public static byte NextByte(ref uint seed)
            {
                seed = Hash(seed);
                return (byte)(seed & 0xFF);
            }

            private static uint CombineHashCodes(uint hash1, uint hash2)
            {
                uint result = hash1;
                result = ((result << 5) + result) ^ hash2;
                return result;
            }
        }
        #endregion
        //-------------------------

        //Adding elements to UI-------------------------------------------------------------
        protected override PropertyCollection OnCreatePropertyCollection()
        {
            List<Property> props = new List<Property>();

            props.Add(new StringProperty(PropertyNames.AlertStr, ""));
            props.Add(new StringProperty(PropertyNames.PromptStr, "", 32767));
            props.Add(new StringProperty(PropertyNames.NgtPromptStr, "", 32767));
            props.Add(new Int32Property(PropertyNames.StepCount, 50, 1, 150));
            props.Add(new Int32Property(PropertyNames.DeNoiseStrength, 90, 0, 100));
            props.Add(new Int32Property(PropertyNames.GenButton, 0, 0, 255));

            return new PropertyCollection(props);
        }

        protected override ControlInfo OnCreateConfigUI(PropertyCollection props)
        {
            ControlInfo configUI = CreateDefaultConfigUI(props);

            configUI.SetPropertyControlValue(PropertyNames.AlertStr, ControlInfoPropertyNames.DisplayName, string.Empty);
            configUI.SetPropertyControlValue(PropertyNames.AlertStr, ControlInfoPropertyNames.Description, "Alert: Please enter prompts");
            configUI.SetPropertyControlType(PropertyNames.AlertStr, PropertyControlType.Label);
            configUI.SetPropertyControlValue(PropertyNames.AlertStr, ControlInfoPropertyNames.ShowHeaderLine, false);
            configUI.SetPropertyControlValue(PropertyNames.PromptStr, ControlInfoPropertyNames.DisplayName, "Prompts:");
            configUI.SetPropertyControlType(PropertyNames.PromptStr, PropertyControlType.TextBox);
            configUI.SetPropertyControlValue(PropertyNames.PromptStr, ControlInfoPropertyNames.Multiline, true);
            configUI.SetPropertyControlValue(PropertyNames.PromptStr, ControlInfoPropertyNames.ShowHeaderLine, false);
            configUI.SetPropertyControlValue(PropertyNames.NgtPromptStr, ControlInfoPropertyNames.DisplayName, "Negative Prompts (optional):");
            configUI.SetPropertyControlType(PropertyNames.NgtPromptStr, PropertyControlType.TextBox);
            configUI.SetPropertyControlValue(PropertyNames.NgtPromptStr, ControlInfoPropertyNames.Multiline, true);
            configUI.SetPropertyControlValue(PropertyNames.NgtPromptStr, ControlInfoPropertyNames.ShowHeaderLine, false);
            configUI.SetPropertyControlValue(PropertyNames.StepCount, ControlInfoPropertyNames.DisplayName, "Steps:");
            configUI.SetPropertyControlValue(PropertyNames.StepCount, ControlInfoPropertyNames.ShowHeaderLine, false);
            configUI.SetPropertyControlValue(PropertyNames.DeNoiseStrength, ControlInfoPropertyNames.DisplayName, "Denoising Strength (%):");
            configUI.SetPropertyControlValue(PropertyNames.DeNoiseStrength, ControlInfoPropertyNames.ShowHeaderLine, false);
            configUI.SetPropertyControlValue(PropertyNames.GenButton, ControlInfoPropertyNames.DisplayName, string.Empty);
            configUI.SetPropertyControlType(PropertyNames.GenButton, PropertyControlType.IncrementButton);
            configUI.SetPropertyControlValue(PropertyNames.GenButton, ControlInfoPropertyNames.ButtonText, "Generate");
            configUI.SetPropertyControlValue(PropertyNames.GenButton, ControlInfoPropertyNames.ShowHeaderLine, false);


            return configUI;
        }

        protected override void OnCustomizeConfigUIWindowProperties(PropertyCollection props)
        {
            // Change the effect's window title
            props[ControlInfoPropertyNames.WindowTitle].Value = "Diffusion";
            // Add help button to effect UI
            props[ControlInfoPropertyNames.WindowHelpContentType].Value = WindowHelpContentType.PlainText;
            props[ControlInfoPropertyNames.WindowHelpContent].Value = "DiffusionPlugin v1.0\nCopyright ©2025 by \nAll rights reserved.";
            base.OnCustomizeConfigUIWindowProperties(props);
        }
        //----------------------------------------------------------------------------------

        //Rendering section-----------------------------------------------------------------
        protected override void OnInitializeRenderInfo(IBitmapEffectRenderInfo renderInfo)
        {
            base.OnInitializeRenderInfo(renderInfo);            
        }

   

        #region User Entered Code

        #region UICode
        LabelComment alertStr = "Alert: Please enter prompts"; // Alert
        MultiLineTextboxControl promptStr = ""; // [32767] Prompts:
        MultiLineTextboxControl ngtPromptStr = ""; // [32767] Negative Prompts (optional):
        IntSliderControl stepCount = 50; // [1,150] Steps:
        IntSliderControl deNoiseStrength = 90; // [0,100] Denoising Strength (%):
        ReseedButtonControl genButton = oldValue; // Generate
        #endregion

        /// <summary>
        /// Store old state of Generate button.
        /// </summary>
        public static System.Byte oldValue = 0;

        /// <summary>
        /// Store result from API.
        /// </summary>
        private static Surface diffusedImg = null;

        /// <summary>
        /// Static object for HttpClient, avoid port exhaustion.
        /// </summary>
        private static readonly HttpClient httpClient = CreateClient();

        /// <summary>
        /// Localhost url for AUTOMATIC1111 API, change this when deploy for public use.
        /// </summary>
        private static readonly string url = "http://127.0.0.1:7860/sdapi/v1/img2img";

        /// <summary>
        /// Create HttpClient and set maximum timeout, change this for larger images.
        /// </summary>
        /// <param name="minute"></param>
        /// <returns></returns>
        private static HttpClient CreateClient(double minute = 2)
        {

            HttpClient client = new HttpClient();
            client.Timeout = TimeSpan.FromMinutes(minute);
            return client;
        }

        protected void OnPropertyChanged(string propertyName) {
            throw new Exception(propertyName);

        }


        /// <summary>
        /// Detect Generate button click and start sending HTTP Request to server, suffers from the multiple button click bug (Un-solved).
        /// </summary>
        /// <param name="newToken"></param>
        protected override void OnSetToken(PropertyBasedEffectConfigToken newToken)
        {
            //Read genButton value and to-be-updated value stored in the token
            var genButtonValue = genButton;
            var newValue = newToken.GetProperty<Int32Property>(PropertyNames.GenButton).Value;



            promptStr = newToken.GetProperty<StringProperty>(PropertyNames.PromptStr).Value;
            ngtPromptStr = newToken.GetProperty<StringProperty>(PropertyNames.NgtPromptStr).Value;
            stepCount = newToken.GetProperty<Int32Property>(PropertyNames.StepCount).Value;
            deNoiseStrength = newToken.GetProperty<Int32Property>(PropertyNames.DeNoiseStrength).Value;
            genButton = (byte)newToken.GetProperty<Int32Property>(PropertyNames.GenButton).Value;
            base.OnSetToken(newToken);

            //Skip if Generate button has not been clicked
            if (genButtonValue + 1 != newValue)
                return;

            //Skip if there is no prompt
            if (promptStr.Length <= 0)
                return;

            var selectedArea = Environment.Selection.RenderBounds.Area;
            var Size = Environment.Document.Size;

            //If there is no selection exist
            if (selectedArea >= Size.Width * Size.Height)
                return;


            //Condition satisfied, start inpainting

            //Get image and mask as Base64
            string canvasB64 = GetCanvasAsBase64();
            string maskB64 = GetMask_by_SelectedZone_AsBase64();

            //Get prompt and hyper-parameters
            string prompt = promptStr;
            string negativePrompt = ngtPromptStr;
            int steps = stepCount;
            double denoise = (deNoiseStrength * 1.0) / 100;

            //Start an async POST request to the server
            string diffusedB64 = PostDiffusionAPI(canvasB64, maskB64, prompt, negativePrompt, steps, denoise).GetAwaiter().GetResult();

            //Receive and process the base64 string result into an image
            if (diffusedB64 != null)
            {
                byte[] imageBytes = Convert.FromBase64String(diffusedB64);
                using var stream = new MemoryStream(imageBytes);
                using var bmp = new System.Drawing.Bitmap(stream);
                Surface surface = new Surface(bmp.Width, bmp.Height);

                BitmapData bmpData = bmp.LockBits(
                        new Rectangle(0, 0, bmp.Width, bmp.Height),
                        ImageLockMode.ReadOnly,
                        System.Drawing.Imaging.PixelFormat.Format32bppArgb
                    );

                try
                {
                    unsafe
                    {
                        ColorBgra* srcPtr = (ColorBgra*)bmpData.Scan0.ToPointer();
                        for (int y = 0; y < bmp.Height; y++)
                        {
                            for (int x = 0; x < bmp.Width; x++)
                            {
                                surface[x, y] = srcPtr[y * (bmpData.Stride / 4) + x];
                            }
                        }
                    }
                }
                finally
                {
                    bmp.UnlockBits(bmpData);
                }
                diffusedImg = surface;
            }
        }

        /// <summary>
        /// Render images by tiles. Display the result from Server (if any) or display the current canvas.
        /// </summary>
        /// <param name="output"></param>
        protected override void OnRender(IBitmapEffectOutput output)
        {
            //Get some coordination information
            using IEffectInputBitmap<ColorBgra32> sourceBitmap = Environment.GetSourceBitmapBgra32();
            using IBitmapLock<ColorBgra32> sourceLock = sourceBitmap.Lock(new RectInt32(0, 0, sourceBitmap.Size));
            RegionPtr<ColorBgra32> sourceRegion = sourceLock.AsRegionPtr();

            RectInt32 outputBounds = output.Bounds;
            using IBitmapLock<ColorBgra32> outputLock = output.LockBgra32();
            RegionPtr<ColorBgra32> outputSubRegion = outputLock.AsRegionPtr();
            var outputRegion = outputSubRegion.OffsetView(-outputBounds.Location);


            //Show the diffusion result if any
            if (diffusedImg != null)
            {
                for (int y = outputBounds.Top; y < outputBounds.Bottom; ++y)
                {
                    if (IsCancelRequested) return;

                    for (int x = outputBounds.Left; x < outputBounds.Right; ++x)
                    {
                        ColorBgra32 sourcePixel = diffusedImg[x, y];
                        outputRegion[x, y] = sourcePixel;
                    }
                }

            }
            else
            {
                //Or render the original canvas instead to avoid scattering
                for (int y = outputBounds.Top; y < outputBounds.Bottom; ++y)
                {
                    if (IsCancelRequested) return;

                    for (int x = outputBounds.Left; x < outputBounds.Right; ++x)
                    {
                        ColorBgra32 sourcePixel = sourceRegion[x, y];
                        // Save your pixel to the output canvas
                        outputRegion[x, y] = sourcePixel;
                    }
                }
            }


        }

        /// <summary>
        /// Start an async POST request to the server with image, mask and given parameters, receive the image as Base64 string.
        /// </summary>
        /// <param name="canvasB64"></param>
        /// <param name="maskB64"></param>
        /// <param name="prompt"></param>
        /// <param name="negativePrompt"></param>
        /// <param name="stepCount"></param>
        /// <param name="denoiseStrength"></param>
        /// <returns></returns>
        private async Task<string> PostDiffusionAPI(string canvasB64, string maskB64, string prompt, string negativePrompt, int stepCount, double denoiseStrength)
        {
            var payload = new
            {
                seed = -1,
                prompt = prompt,
                negative_prompt = negativePrompt,

                resize_mode = 0,
                inpaint_full_res = true,
                inpaint_full_res_padding = 32,
                inpainting_fill = 1,

                steps = stepCount,
                cfg_scale = 10,
                denoising_strength = denoiseStrength,

                sampler_name = "DPM++ SDE",
                scheduler = "Karras",

                init_images = new List<string> { canvasB64 },
                mask = maskB64
            };


            string jsonContent = JsonSerializer.Serialize(payload);
            HttpContent content = new StringContent(jsonContent, UTF8Encoding.UTF8, "application/json");
            HttpResponseMessage response = (await httpClient.PostAsync(url, content));
            response.EnsureSuccessStatusCode();

            string responseJson = await response.Content.ReadAsStringAsync();
            using JsonDocument doc = JsonDocument.Parse(responseJson);
            var base64Img = doc.RootElement.GetProperty("images")[0].GetString();

            return base64Img;
        }

        /// <summary>
        /// Convert 2d image into Base64 string.
        /// </summary>
        /// <returns></returns>
        private string GetCanvasAsBase64()
        {
            using IEffectInputBitmap<ColorBgra32> sourceBitmap = Environment.GetSourceBitmapBgra32();
            Size canvasSize = sourceBitmap.Size;

            using IBitmapLock<ColorBgra32> sourceLock = sourceBitmap.Lock(new RectInt32(0, 0, canvasSize));
            RegionPtr<ColorBgra32> sourceRegion = sourceLock.AsRegionPtr();

            using var stream = new MemoryStream();

            using Bitmap bmp = new Bitmap(canvasSize.Width, canvasSize.Height, System.Drawing.Imaging.PixelFormat.Format32bppArgb);

            for (int y = 0; y < canvasSize.Height; y++)
            {
                for (int x = 0; x < canvasSize.Width; x++)
                {
                    ColorBgra32 pixel = sourceRegion[x, y];
                    bmp.SetPixel(x, y, System.Drawing.Color.FromArgb(pixel.A, pixel.R, pixel.G, pixel.B));
                }
            }

            bmp.Save(stream, System.Drawing.Imaging.ImageFormat.Png);

            return Convert.ToBase64String(stream.ToArray());
        }

        /// <summary>
        /// Convert the selected zone into a mask as Base64 string.
        /// </summary>
        /// <returns></returns>
        private string GetMask_by_SelectedZone_AsBase64()
        {
            Size maskSize = Environment.Selection.MaskBitmap.Size;
            IBitmapLock<ColorAlpha8> maskLock = Environment.Selection.MaskBitmap.Lock(new RectInt32(0, 0, maskSize));
            RegionPtr<ColorAlpha8> maskRegion = maskLock.AsRegionPtr();

            using var stream = new MemoryStream();

            using Bitmap maskBmp = new Bitmap(maskSize.Width, maskSize.Height, System.Drawing.Imaging.PixelFormat.Format32bppArgb);

            for (int y = 0; y < maskSize.Height; y++)
            {
                for (int x = 0; x < maskSize.Width; x++)
                {
                    Color maskPixel = Color.FromArgb(maskRegion[x, y].A > 127 ? 255 : 0, 255, 255, 255);
                    maskBmp.SetPixel(x, y, maskPixel);
                }
            }
            maskBmp.Save(stream, System.Drawing.Imaging.ImageFormat.Png);

            return Convert.ToBase64String(stream.ToArray());
        }

        /// <summary>
        /// Cleanup
        /// </summary>
        /// <param name="disposing"></param>
        protected override void OnDispose(bool disposing)
        {
            if (disposing)
            {
                oldValue = genButton;
                if (diffusedImg != null)
                {
                    diffusedImg.Dispose();
                    diffusedImg = null;
                }
            }
            base.OnDispose(disposing);
        }
        #endregion
    }
}